{"title":"Assignment 4: Spatial Predictive Analysis","markdown":{"yaml":{"title":"Assignment 4: Spatial Predictive Analysis","author":"Zimu DENG (Mark)","date":"today","format":{"html":{"code-fold":"show","toc":true,"toc-location":"left","theme":"cosmo","embed-resources":true}},"execute":{"warning":false,"message":false}},"headingText":"Assignment Overview","containsRefs":false,"markdown":"\n\n\nIn this lab, I will apply the spatial predictive modeling techniques demonstrated in the class exercise to a 311 service request type of my choice. I will build a complete spatial predictive model, document your process, and interpret my results.\n\n**Learning Objectives:** - Adapt example code to analyze a new dataset - Build spatial features for predictive modeling - Apply count regression techniques to spatial data - Implement spatial cross-validation - Interpret and communicate model results - Critically evaluate model performance\n\n------------------------------------------------------------------------\n\n## Setup\n\n```{r}\n#| message: false\n#| warning: false\n\n# Load required packages\nlibrary(tidyverse)      # Data manipulation\nlibrary(sf)             # Spatial operations\nlibrary(here)           # Relative file paths\nlibrary(viridis)        # Color scales\nlibrary(terra)          # Raster operations (replaces 'raster')\nlibrary(spdep)          # Spatial dependence\nlibrary(FNN)            # Fast nearest neighbors\nlibrary(MASS)           # Negative binomial regression\nlibrary(patchwork)      # Plot composition (replaces grid/gridExtra)\nlibrary(knitr)          # Tables\nlibrary(kableExtra)     # Table formatting\nlibrary(classInt)       # Classification intervals\nlibrary(here)\n\n# Spatstat split into sub-packages\nlibrary(spatstat.geom)    # Spatial geometries\nlibrary(spatstat.explore) # Spatial exploration/KDE\n\n# Set options\noptions(scipen = 999)  # No scientific notation\nset.seed(5080)         # Reproducibility\n\n# Create consistent theme for visualizations\ntheme_crime <- function(base_size = 11) {\n  theme_minimal(base_size = base_size) +\n    theme(\n      plot.title = element_text(face = \"bold\", size = base_size + 1),\n      plot.subtitle = element_text(color = \"gray30\", size = base_size - 1),\n      legend.position = \"right\",\n      panel.grid.minor = element_blank(),\n      axis.text = element_blank(),\n      axis.title = element_blank()\n    )\n}\n\n# Set as default\ntheme_set(theme_crime())\n\ncat(\"✓ All packages loaded successfully!\\n\")\ncat(\"✓ Working directory:\", getwd(), \"\\n\")\n```\n\n## Step 1: My 311 Violation Type\n\nI chose the 311 service request type “Alley Light Out” as my violation because it provides a useful proxy for local guardianship and physical disorder when predicting burglaries. Reports of broken or non-functioning alley lights indicate areas that are poorly illuminated and less visible to neighbors or passers-by. From an environmental criminology perspective, these darker, less supervised micro-environments reduce natural surveillance and increase offenders’ perceived anonymity, making nearby properties more attractive targets for break-ins. Thus, the spatial pattern of alley-light-out complaints can reasonably be expected to correlate with higher burglary risk.\n\n## Step 2: My Analysis\n\n#### Part 1: Data Loading & Exploration\n\n```{r}\n# Load 311 data (Alley lights out)\nalley_lights <- read_csv(\"data/311_Alley_Lights_Out_2017.csv\")%>%\n  filter(!is.na(Latitude), !is.na(Longitude)) %>%\n  st_as_sf(coords = c(\"Longitude\", \"Latitude\"), crs = 4326) %>%\n  st_transform('ESRI:102271')\n```\n\n```{r}\n#| message: false\n\n# Load police districts (used for spatial cross-validation)\npoliceDistricts <- \n  st_read(\"https://data.cityofchicago.org/api/geospatial/24zt-jpfn?method=export&format=GeoJSON\") %>%\n  st_transform('ESRI:102271') %>%\n  dplyr::select(District = dist_num)\n\n# Load police beats (smaller administrative units)\npoliceBeats <- \n  st_read(\"https://data.cityofchicago.org/api/geospatial/n9it-hstw?method=export&format=GeoJSON\") %>%\n  st_transform('ESRI:102271') %>%\n  dplyr::select(Beat = beat_num)\n\n# Load Chicago boundary\nchicagoBoundary <- \n  st_read(\"https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/Chapter5/chicagoBoundary.geojson\") %>%\n  st_transform('ESRI:102271')\n\ncat(\"✓ Loaded spatial boundaries\\n\")\ncat(\"  - Police districts:\", nrow(policeDistricts), \"\\n\")\ncat(\"  - Police beats:\", nrow(policeBeats), \"\\n\")\n```\n\n```{r}\n#| fig-width: 10\n#| fig-height: 5\n\n## Visualization and Spatial Distribution\n# Simple point map\np1 <- ggplot() + \n  geom_sf(data = chicagoBoundary, fill = \"gray95\", color = \"gray60\") +\n  geom_sf(data = alley_lights, color = \"#d62828\", size = 0.1, alpha = 0.4) +\n  labs(\n    title = \"Alley Lights Out Locations\",\n    subtitle = paste0(\"Chicago 2017, n = \", nrow(alley_lights))\n  )\n\n# Density surface using modern syntax\np2 <- ggplot() + \n  geom_sf(data = chicagoBoundary, fill = \"gray95\", color = \"gray60\") +\n  geom_density_2d_filled(\n    data = data.frame(st_coordinates(alley_lights)),\n    aes(X, Y),\n    alpha = 0.7,\n    bins = 8\n  ) +\n  scale_fill_viridis_d(\n    option = \"plasma\",\n    direction = -1,\n    guide = \"none\"  # Modern ggplot2 syntax (not guide = FALSE)\n  ) +\n  labs(\n    title = \"Density Surface\",\n    subtitle = \"Kernel density estimation\"\n  )\n\n# Combine plots using patchwork (modern approach)\np1 + p2 + \n  plot_annotation(\n    title = \"Spatial Distribution of Alley Lights Out in Chicago, 2017\",\n    tag_levels = 'A'\n  )\n```\n\nSpatial Pattern: The maps show that alley-light-out reports are not evenly distributed across Chicago, but cluster in a few broad corridors. Complaints are most concentrated in a north–south band through the western and southwestern residential neighborhoods, with several pronounced hotspots in the central and South Side areas. In contrast, the lakefront, downtown core, and some far-north and far-south edges have relatively few reports, suggesting better lighting conditions or fewer alleys in those parts of the city.\n\n#### Part 2: Fishnet Grid Creation\n\n```{r}\n# Create 500m x 500m grid\nfishnet_raw <- st_make_grid(\n  chicagoBoundary,\n  cellsize = 500,  # 500 meters per cell\n  square = TRUE\n) %>%\n  st_sf() %>%\n  mutate(uniqueID = row_number())\n\n# Keep only cells that intersect Chicago\nfishnet_raw <- fishnet_raw[chicagoBoundary, ]\n\n# View basic info\ncat(\"✓ Created fishnet grid\\n\")\ncat(\"  - Number of cells:\", nrow(fishnet_raw), \"\\n\")\ncat(\"  - Cell size:\", 500, \"x\", 500, \"meters\\n\")\ncat(\"  - Cell area:\", round(st_area(fishnet_raw[1,])), \"square meters\\n\")\n```\n\n```{r}\n# Spatial join\nalley_lights_fishnet <- st_join(alley_lights, fishnet_raw, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countAlleyLights = n())\n\n# Join back to fishnet (cells with 0 will be NA)\nfishnet_raw <- fishnet_raw %>%\n  left_join(alley_lights_fishnet, by = \"uniqueID\") %>%\n  mutate(countAlleyLights = replace_na(countAlleyLights, 0))\n\n# Summary statistics\ncat(\"\\nAlleyLights count distribution:\\n\")\nsummary(fishnet_raw$countAlleyLights)\ncat(\"\\nCells with zero AlleyLights:\", \n    sum(fishnet_raw$countAlleyLights == 0), \n    \"/\", nrow(fishnet_raw),\n    \"(\", round(100 * sum(fishnet_raw$countAlleyLights == 0) / nrow(fishnet_raw), 1), \"%)\\n\")\n```\n\n```{r}\n#| fig-width: 8\n#| fig-height: 6\n\n# Visualize aggregated counts\nggplot() +\n  geom_sf(data = fishnet_raw, aes(fill = countAlleyLights), color = NA) +\n  geom_sf(data = chicagoBoundary, fill = NA, color = \"white\", linewidth = 1) +\n  scale_fill_viridis_c(\n    name = \"Alley Lights Out\",\n    option = \"plasma\",\n    trans = \"sqrt\",  # Square root for better visualization of skewed data\n    breaks = c(0, 20, 50, 100, 150)\n  ) +\n  labs(\n    title = \"Alley Lights Out Counts by Grid Cell\",\n    subtitle = \"500m x 500m cells, Chicago 2017\"\n  ) +\n  theme_crime()\n```\n\n#### Part 3: Spatial Features\n\n```{r}\n## Calculate k-nearest neighbor features\n\n# Get coordinates\nfishnet_coords <- st_coordinates(st_centroid(fishnet_raw))\nlights_coords <- st_coordinates(alley_lights)\n\n# Calculate k nearest neighbors and distances\nnn_result <- get.knnx(lights_coords, fishnet_coords, k = 3)\n\n# Add to fishnet\nfishnet <- fishnet_raw %>%\n  mutate(\n    alley_lights.nn = rowMeans(nn_result$nn.dist)\n  )\n\ncat(\"✓ Calculated nearest neighbor distances\\n\")\nsummary(fishnet$alley_lights.nn)\n\n```\n\n```{r}\n## Local Moran'I\n\n# Function to calculate Local Moran's I\ncalculate_local_morans <- function(data, variable, k = 5) {\n  \n  # Create spatial weights\n  coords <- st_coordinates(st_centroid(data))\n  neighbors <- knn2nb(knearneigh(coords, k = k))\n  weights <- nb2listw(neighbors, style = \"W\", zero.policy = TRUE)\n  \n  # Calculate Local Moran's I\n  local_moran <- localmoran(data[[variable]], weights)\n  \n  # Classify clusters\n  mean_val <- mean(data[[variable]], na.rm = TRUE)\n  \n  data %>%\n    mutate(\n      local_i = local_moran[, 1],\n      p_value = local_moran[, 5],\n      is_significant = p_value < 0.05,\n      \n      moran_class = case_when(\n        !is_significant ~ \"Not Significant\",\n        local_i > 0 & .data[[variable]] > mean_val ~ \"High-High\",\n        local_i > 0 & .data[[variable]] <= mean_val ~ \"Low-Low\",\n        local_i < 0 & .data[[variable]] > mean_val ~ \"High-Low\",\n        local_i < 0 & .data[[variable]] <= mean_val ~ \"Low-High\",\n        TRUE ~ \"Not Significant\"\n      )\n    )\n}\n\n# Apply function\nfishnet <- calculate_local_morans(fishnet, \"countAlleyLights\", k = 5)\n```\n\n```{r}\n## Identify Hot Spot\n\n#| fig-width: 8\n#| fig-height: 6\n\n# Visualize hot spots\nggplot() +\n  geom_sf(\n    data = fishnet, \n    aes(fill = moran_class), \n    color = NA\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"High-High\" = \"#d7191c\",\n      \"High-Low\" = \"#fdae61\",\n      \"Low-High\" = \"#abd9e9\",\n      \"Low-Low\" = \"#2c7bb6\",\n      \"Not Significant\" = \"gray90\"\n    ),\n    name = \"Cluster Type\"\n  ) +\n  labs(\n    title = \"Local Moran's I: Alley Lights Out Clusters\",\n    subtitle = \"High-High = Hot spots of lights out\"\n  ) +\n  theme_crime()\n```\nInterpretation: The Local Moran’s I results show that alley-light-out complaints are not randomly distributed, but form several statistically significant clusters. High–High cells (in red) – grid cells with high numbers of outages surrounded by similarly high neighbors – concentrate in contiguous bands in the central–west and southwest parts of the city, with additional pockets on the South Side. These areas represent local hot spots of poor alley lighting conditions. A few Low–High cells (in blue) appear on the edges of these clusters, indicating outliers. Most of the remaining grid cells are not significant.\n\n```{r}\n## Distance-to-hotspots\n\n# Get centroids of \"High-High\" cells (hot spots)\nhotspots <- fishnet %>%\n  filter(moran_class == \"High-High\") %>%\n  st_centroid()\n\n# Calculate distance from each cell to nearest hot spot\nif (nrow(hotspots) > 0) {\n  fishnet <- fishnet %>%\n    mutate(\n      dist_to_hotspot = as.numeric(\n        st_distance(st_centroid(fishnet), hotspots %>% st_union())\n      )\n    )\n  \n  cat(\"✓ Calculated distance to alley lights out hot spots\\n\")\n  cat(\"  - Number of hot spot cells:\", nrow(hotspots), \"\\n\")\n} else {\n  fishnet <- fishnet %>%\n    mutate(dist_to_hotspot = 0)\n  cat(\"⚠ No significant hot spots found\\n\")\n}\n```\n\n#### Part 4: Count Regression Models\n\n```{r}\n## load-burglaries\n\n#| message: false\n\n# Load from provided data file (downloaded from Chicago open data portal)\nburglaries <- st_read(\"data/burglaries.shp\") %>% \n  st_transform('ESRI:102271')\n\n# Check the data\ncat(\"\\n✓ Loaded burglary data\\n\")\ncat(\"  - Number of burglaries:\", nrow(burglaries), \"\\n\")\ncat(\"  - CRS:\", st_crs(burglaries)$input, \"\\n\")\ncat(\"  - Date range:\", min(burglaries$date, na.rm = TRUE), \"to\", \n    max(burglaries$date, na.rm = TRUE), \"\\n\")\n```\n\n```{r}\n## Aggregate burglary data to fishnet\n\n# Spatial join: which cell contains each burglary?\nburglaries_fishnet <- st_join(burglaries, fishnet, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countBurglaries = n())\n\n# Join back to fishnet (cells with 0 burglaries will be NA)\nfishnet <- fishnet %>%\n  left_join(burglaries_fishnet, by = \"uniqueID\") %>%\n  mutate(countBurglaries = replace_na(countBurglaries, 0))\n\n# Summary statistics\ncat(\"\\nBurglary count distribution:\\n\")\nsummary(fishnet$countBurglaries)\ncat(\"\\nCells with zero burglaries:\", \n    sum(fishnet$countBurglaries == 0), \n    \"/\", nrow(fishnet),\n    \"(\", round(100 * sum(fishnet$countBurglaries == 0) / nrow(fishnet), 1), \"%)\\n\")\n```\n\n```{r}\n## KDE \n\n#| message: false\n\n# Convert burglaries to ppp (point pattern) format for spatstat\nburglaries_ppp <- as.ppp(\n  st_coordinates(burglaries),\n  W = as.owin(st_bbox(chicagoBoundary))\n)\n\n# Calculate KDE with 1km bandwidth\nkde_burglaries <- density.ppp(\n  burglaries_ppp,\n  sigma = 1000,  # 1km bandwidth\n  edge = TRUE    # Edge correction\n)\n\n# Convert to terra raster (modern approach, not raster::raster)\nkde_raster <- rast(kde_burglaries)\n\n# Extract KDE values to fishnet cells\nfishnet <- fishnet %>%\n  mutate(\n    kde_value = terra::extract(\n      kde_raster,\n      vect(fishnet),\n      fun = mean,\n      na.rm = TRUE\n    )[, 2]  # Extract just the values column\n  )\n\ncat(\"✓ Calculated KDE baseline\\n\")\n```\n\n```{r}\n# Join district information to fishnet\nfishnet <- st_join(\n  fishnet,\n  policeDistricts,\n  join = st_within,\n  left = TRUE\n) %>%\n  filter(!is.na(District))  # Remove cells outside districts\n\ncat(\"✓ Joined police districts\\n\")\ncat(\"  - Districts:\", length(unique(fishnet$District)), \"\\n\")\ncat(\"  - Cells:\", nrow(fishnet), \"\\n\")\n```\n\n```{r}\n## Fit Poisson regression\n# Create clean modeling dataset\nfishnet_model <- fishnet %>%\n  st_drop_geometry() %>%\n  dplyr::select(\n    uniqueID,\n    District,\n    countBurglaries,\n    countAlleyLights,\n    alley_lights.nn,\n    dist_to_hotspot\n  ) %>%\n  na.omit()  # Remove any remaining NAs\n\n#Poisson regression\nmodel_poisson <- glm(\n  countBurglaries ~ countAlleyLights + alley_lights.nn + dist_to_hotspot,\n  data = fishnet_model,\n  family = \"poisson\"\n)\n\n# Summary\nsummary(model_poisson)\n```\n\n```{r}\n# Calculate dispersion parameter\ndispersion <- sum(residuals(model_poisson, type = \"pearson\")^2) / \n              model_poisson$df.residual\n\ncat(\"Dispersion parameter:\", round(dispersion, 2), \"\\n\")\ncat(\"Rule of thumb: >1.5 suggests overdispersion\\n\")\n\nif (dispersion > 1.5) {\n  cat(\"⚠ Overdispersion detected! Consider Negative Binomial model.\\n\")\n} else {\n  cat(\"✓ Dispersion looks okay for Poisson model.\\n\")\n}\n```\n\n```{r}\n# Fit Negative Binomial model\nmodel_nb <- glm.nb(\n  countBurglaries ~ countAlleyLights + alley_lights.nn + dist_to_hotspot,\n  data = fishnet_model\n)\n\n# Summary\nsummary(model_nb)\n\n# Compare AIC (lower is better)\ncat(\"\\nModel Comparison:\\n\")\ncat(\"Poisson AIC:\", round(AIC(model_poisson), 1), \"\\n\")\ncat(\"Negative Binomial AIC:\", round(AIC(model_nb), 1), \"\\n\")\n```\nComparison between 2 models: The Poisson model shows strong overdispersion, with a dispersion parameter of about 3.28 (>1.5), indicating that the variance is much larger than the mean and the Poisson assumption is violated, so Negative Binomial model should be applied. Compared with the Poisson model, the Negative Binomial model provides a clearly superior fit to the burglary counts, its AIC (7562.6) is dramatically lower than the Poisson AIC (9057.4).\n\n#### Part 5: Spatial Cross-Validation (2017)\n\n```{r}\n# Get unique districts\ndistricts <- unique(fishnet_model$District)\ncv_results <- tibble()\n\ncat(\"Running LOGO Cross-Validation...\\n\")\n\nfor (i in seq_along(districts)) {\n  \n  test_district <- districts[i]\n  \n  # Split data\n  train_data <- fishnet_model %>% filter(District != test_district)\n  test_data <- fishnet_model %>% filter(District == test_district)\n  \n  # Fit model on training data\n  model_cv <- glm.nb(\n    countBurglaries ~ countAlleyLights + alley_lights.nn + dist_to_hotspot,\n    data = train_data\n  )\n  \n  # Predict on test data\n  test_data <- test_data %>%\n    mutate(\n      prediction = predict(model_cv, test_data, type = \"response\")\n    )\n  \n  # Calculate metrics\n  mae <- mean(abs(test_data$countBurglaries - test_data$prediction))\n  rmse <- sqrt(mean((test_data$countBurglaries - test_data$prediction)^2))\n  \n  # Store results\n  cv_results <- bind_rows(\n    cv_results,\n    tibble(\n      fold = i,\n      test_district = test_district,\n      n_test = nrow(test_data),\n      mae = mae,\n      rmse = rmse\n    )\n  )\n  \n  cat(\"  Fold\", i, \"/\", length(districts), \"- District\", test_district, \n      \"- MAE:\", round(mae, 2), \"\\n\")\n}\n\n# Overall results\ncat(\"\\n✓ Cross-Validation Complete\\n\")\ncat(\"Mean MAE:\", round(mean(cv_results$mae), 2), \"\\n\")\ncat(\"Mean RMSE:\", round(mean(cv_results$rmse), 2), \"\\n\")\n\n```\n\nDiscussion: In this step I use spatial cross-validation, leaving out one police district at a time (LOGO CV). The reason for using a spatial CV scheme instead of random k-folds is that burglary patterns might be spatially autocorrelated: nearby cells look more similar than distant ones. A random split would mix neighboring cells across training and test sets, making the test data “too easy” and over-optimistic about model performance. By holding out an entire district, I can reveal how well does the model trained on some parts of Chicago generalize to a completely new area, which is a more robust way to test the prediction ability.\n\nThe results suggest that the model’s out-of-sample predictive ability is only low-moderate. The average MAE across folds is about 2.58 burglaries per grid cell, and the mean RMSE is 3.5, which are large. There is also substantial variation across districts: some folds have relatively low errors (MAE around 1.8–2.0), while others—such as District 3—show much higher errors (MAE above 5). This pattern indicates that the model captures some broad spatial structure, but its ability to generalize to all districts is limited, and performance degrades notably in certain areas.\n\n#### Part 6: Model Evaluation (Spatial and Temporal)\n\n#### Part 6.0 Use Final Model to Make Predictions\n\n```{r}\nfinal_model <- glm.nb(\n  countBurglaries ~ countAlleyLights + alley_lights.nn + dist_to_hotspot,\n  data = fishnet_model\n)\n```\n\n```{r}\n## Generate three predictors for 2018\n\n# 0) Load 2018 311 data\nalley_lights_2018 <- read_csv(\"data/311_Alley_Lights_Out_2018.csv\")%>%\n  filter(!is.na(Latitude), !is.na(Longitude)) %>%\n  st_as_sf(coords = c(\"Longitude\", \"Latitude\"), crs = 4326) %>%\n  st_transform('ESRI:102271')\n\n# 0) Prepare 500m x 500m grid for 2018\nfishnet2 <- st_make_grid(\n  chicagoBoundary,\n  cellsize = 500,  # 500 meters per cell\n  square = TRUE\n) %>%\n  st_sf() %>%\n  mutate(uniqueID = row_number())\n\nfishnet2 <- fishnet2[chicagoBoundary, ]\n\n# 1) Aggregate into fishnet\nalley_lights_fishnet_2018 <- st_join(alley_lights_2018, fishnet2, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countAlleyLights = n())\n\n# Join back to fishnet (cells with 0 will be NA)\nfishnet2 <- fishnet2 %>%\n  left_join(alley_lights_fishnet_2018, by = \"uniqueID\") %>%\n  mutate(countAlleyLights = replace_na(countAlleyLights, 0))\n\n# 2) Calculate k-nearest neighbor features\nfishnet2_coords <- st_coordinates(st_centroid(fishnet2))\nlights2018_coords <- st_coordinates(alley_lights_2018)\n\n# Calculate k nearest neighbors and distances\nnn_result2 <- get.knnx(lights2018_coords, fishnet2_coords, k = 3)\n\n# Add to fishnet\nfishnet2 <- fishnet2 %>%\n  mutate(\n    alley_lights.nn = rowMeans(nn_result2$nn.dist)\n  )\n\n# 3) Distance to hotspot\n# Apply function\nfishnet2 <- calculate_local_morans(fishnet2, \"countAlleyLights\", k = 5)\n\n# Get centroids of \"High-High\" cells (hot spots)\nhotspots <- fishnet2 %>%\n  filter(moran_class == \"High-High\") %>%\n  st_centroid()\n\nif (nrow(hotspots) > 0) {\n  fishnet2 <- fishnet2 %>%\n    mutate(\n      dist_to_hotspot = as.numeric(\n        st_distance(st_centroid(fishnet2), hotspots %>% st_union())\n      )\n    )\n  \n  cat(\"✓ Calculated distance to alley lights out hot spots\\n\")\n  cat(\"  - Number of hot spot cells:\", nrow(hotspots), \"\\n\")\n} else {\n  fishnet <- fishnet %>%\n    mutate(dist_to_hotspot = 0)\n  cat(\"⚠ No significant hot spots found\\n\")\n}\n\n```\n\n```{r}\n## burglaries data for 2018\nburglaries_2018 <- st_read(\"data/burglaries_2018.geojson\") %>% \n  st_transform('ESRI:102271')\n\n# Spatial join\nburglaries_fishnet2 <- st_join(burglaries_2018, fishnet2, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countBurglaries = n())\n\n# Join back to fishnet (cells with 0 burglaries will be NA)\nfishnet2 <- fishnet2 %>%\n  left_join(burglaries_fishnet2, by = \"uniqueID\") %>%\n  mutate(countBurglaries = replace_na(countBurglaries, 0))\n\n# Create clean dataset for prediction\nfishnet_model_2018 <- fishnet2 %>%\n  st_drop_geometry() %>%\n  dplyr::select(\n    uniqueID,\n    countBurglaries,\n    countAlleyLights,\n    alley_lights.nn,\n    dist_to_hotspot\n  ) %>%\n  na.omit()  # Remove any remaining NAs\n\n```\n\n```{r}\n## Add predictions back to fishnet for both year\n\nfishnet <- fishnet %>%\n  mutate(\n    prediction_nb = predict(final_model, fishnet_model, type = \"response\")[match(uniqueID, fishnet_model$uniqueID)]\n  )\n\nfishnet2 <- fishnet2 %>%\n  mutate(\n    prediction_nb = predict(final_model, fishnet_model_2018, type = \"response\")[match(uniqueID, fishnet_model_2018$uniqueID)]\n  )\n\n# KDE predictions as baseline (normalize to same scale as counts)\nkde_sum <- sum(fishnet$kde_value, na.rm = TRUE)\ncount_sum <- sum(fishnet$countBurglaries, na.rm = TRUE)\nfishnet <- fishnet %>%\n  mutate(\n    prediction_kde = (kde_value / kde_sum) * count_sum\n  )\n```\n\n#### Part 6.1 Compare Model vs. KDE Baseline (Spatially)\n\n```{r}\n#| fig-width: 18\n#| fig-height: 10\n\n# Create three maps\n\np1 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = countBurglaries), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Burglaries, 2017\") +\n  theme_crime()\n\np2 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = prediction_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Model Predictions (Neg. Binomial), 2017\") +\n  theme_crime()\n\np3 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = prediction_kde), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"KDE Baseline Predictions, 2017\") +\n  theme_crime()\n\np1 + p2 + p3 +\n  plot_annotation(\n    title = \"Actual vs. Predicted Burglaries, 2017\",\n    subtitle = \"Caomparasion between actual values, model predictions, and KDE Baseline\"\n  )\n```\n\nDiscussion: Compared with actual plot, the Negative Binomial model reproduces the broad spatial pattern of burglaries in 2017. The model surface is clearly smoother than the real observations: many small, high-intensity hotspots in the actual map are muted or averaged out, and extreme peaks are under-predicted.\n  \nCompared with the KDE baseline, the regression model captures more local variation and better respects the grid/district structure. The KDE surface is very smooth and spreads risk over large blobs, often blurring sharp transitions between high- and low-burglary cells. By contrast, the model predictions show finer spatial detail and align more closely with the observed hotspot pattern, even though they still miss some of the most intense clusters.\n\n#### Part 6.2 Compare Model (Temporally)\n\n```{r}\n#| fig-width: 18\n#| fig-height: 10\n\n# Create three maps\n\np4 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = countBurglaries), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Burglaries, 2018\") +\n  theme_crime()\n\np5 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = prediction_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Model Predictions (Neg. Binomial), 2018\") +\n  theme_crime()\n\np4 + p5 +\n  plot_annotation(\n    title = \"Actual vs. Predicted Burglaries, 2018\",\n    subtitle = \"Caomparasion between actual values and model predictions, 2018\"\n  )\n```\n\nDiscussion: In the temporal validation for 2018, the Negative Binomial model again reproduces the broad spatial structure of burglaries, but the limitations of its predictive power are also apparent. The predicted surface correctly identifies the western and southern parts of the city as higher-risk areas and keeps the lakefront and far-south tip relatively low, so at a coarse scale the model generalizes reasonably well from 2017 to 2018. However, the 2018 predictions are even smoother and more diffuse than in the training year: many of the sharp, localized hotspots visible in the actual 2018 map are blurred into medium-intensity regions, and several newly emerging hotspots are clearly under-predicted. \n\n#### Part 6.3 Map Prediction Errors for 2017 and 2018\n\n```{r}\n## Map prediction errors for 2017 and 2018\n# Calculate errors\nfishnet <- fishnet %>%\n  mutate(\n    error_nb = countBurglaries - prediction_nb,\n    error_kde = countBurglaries - prediction_kde,\n    abs_error_nb = abs(error_nb),\n    abs_error_kde = abs(error_kde)\n  )\n\nfishnet2 <- fishnet2 %>%\n  mutate(\n    error_nb = countBurglaries - prediction_nb,\n    abs_error_nb = abs(error_nb),\n  )\n\n# Map errors\np6 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = error_nb), color = NA) +\n  scale_fill_gradient2(\n    name = \"Error\",\n    low = \"#2166ac\", mid = \"white\", high = \"#b2182b\",\n    midpoint = 0,\n    limits = c(-10, 10)\n  ) +\n  labs(title = \"Model Errors (Actual - Predicted), 2017\") +\n  theme_crime()\n\np7 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = abs_error_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Abs. Error\", option = \"magma\") +\n  labs(title = \"Absolute Model Errors, 2017\") +\n  theme_crime()\n\n\n\np6 + p7\n```\n\n```{r}\n# Map errors\np8 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = error_nb), color = NA) +\n  scale_fill_gradient2(\n    name = \"Error\",\n    low = \"#2166ac\", mid = \"white\", high = \"#b2182b\",\n    midpoint = 0,\n    limits = c(-10, 10)\n  ) +\n  labs(title = \"Model Errors (Actual - Predicted), 2018\") +\n  theme_crime()\n\np9 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = abs_error_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Abs. Error\", option = \"magma\") +\n  labs(title = \"Absolute Model Errors, 2018\") +\n  theme_crime()\n\np8 + p9\n```\n\nDiscussion: Across both years, the error maps show clear local patterns of errors. In 2017, red cells (under-prediction) are concentrated in the main burglary hotspots in the north-western and southern parts of the city, where the model tends to miss the very highest counts. Blue cells (over-prediction) appear more often along the lakefront and some peripheral districts, where actual burglaries are close to zero but the model still assigns non-trivial risk. The absolute-error map confirms that the largest errors are clustered in these high-crime southern and southwestern areas.\n\nIn 2018, the pattern is similar. Cells show sightly lower  absolute errors, but still a handful of high-burglary grids in the south stand out with large residuals. Overall, the model performs best in medium-risk areas and struggles most with extreme hotspots and very low-crime zones.\n\n#### Part 6.4 Performance Metrics\n\n```{r}\n## Calculate performance metrics\n\ncomparison <- fishnet %>%\n  st_drop_geometry() %>%\n  filter(!is.na(prediction_nb), !is.na(prediction_kde)) %>%\n  summarize(\n    model_mae_2017 = mean(abs(countBurglaries - prediction_nb)),\n    model_rmse_2017 = sqrt(mean((countBurglaries - prediction_nb)^2)),\n    kde_mae = mean(abs(countBurglaries - prediction_kde)),\n    kde_rmse = sqrt(mean((countBurglaries - prediction_kde)^2))\n  )\n\ncomparison2 <- fishnet2 %>%\n  st_drop_geometry() %>%\n  filter(!is.na(prediction_nb)) %>%\n  summarize(\n    model_mae_2018 = mean(abs(countBurglaries - prediction_nb)),\n    model_rmse_2018 = sqrt(mean((countBurglaries - prediction_nb)^2))\n  )\n\nperf_table <- tibble::tibble(\n  Model = c(\n    \"KDE Baseline in 2017\",\n    \"NegBin Model in 2017\",\n    \"NegBin Model in 2018\"\n  ),\n  MAE = c(\n    comparison$kde_mae,#### Part 6.4 Performance Metrics\n    comparison$model_mae_2017,\n    comparison2$model_mae_2018\n  ),\n  RMSE = c(\n    comparison$kde_rmse,\n    comparison$model_rmse_2017,\n    comparison2$model_rmse_2018\n  )\n)\n\nperf_table %>%\n  knitr::kable(\n    digits = 2,\n    caption = \"Model Performance Comparison (2017 & 2018)\"\n  ) %>%\n  kableExtra::kable_styling(\n    bootstrap_options = c(\"striped\", \"hover\")\n  )\n```\n\nDiscussion: The performance table shows that the KDE baseline achieves the lowest error in the training year (2017), with MAE 2.06 and RMSE 2.95, while the Negative Binomial model performs slightly worse in 2017 (MAE 2.44, RMSE 3.50). This can be explained by that the KDE baseline is a purely spatial smoothing of the observed burglary counts, so it is very flexible and can closely reproduce the 2017 hotspot pattern, especially when evaluated on the same year it was built from. In contrast, the Negative Binomial model is more relies on a small set of features (alley lights and distance to hotspots) so it cannot capture all the local variation in the training data. \n\nWhen the model is applied to 2018 for temporal validation, its error decreases (MAE 2.17, RMSE 3.18) compared with its 2017 performance, suggesting that its generalization ability is robust across years. Interestingly, the 2018 error is only slightly higher than the KDE baseline in 2017, but lower than the error in 2017. A likely explanation is that the 2018 burglary distribution itself is “easier” to predict. So a supplementary analysis might be required to see the difference of burglaries distribution between 2017 and 2018.\n\n#### Part 6.5 Supplementary Analysis to Discuss the Difference of Burglaries between 2017 and 2018\n\n```{r}\nburg_all <- bind_rows(\n  fishnet_model      %>% st_drop_geometry() %>% mutate(year = \"2017\"),\n  fishnet_model_2018 %>% st_drop_geometry() %>% mutate(year = \"2018\")\n)\n\nburg_summary <- burg_all %>%\n  group_by(year) %>%\n  summarise(\n    mean   = mean(countBurglaries, na.rm = TRUE),\n    sd     = sd(countBurglaries, na.rm = TRUE),\n    median = median(countBurglaries, na.rm = TRUE),\n    p90    = quantile(countBurglaries, 0.9, na.rm = TRUE),\n    max    = max(countBurglaries, na.rm = TRUE),\n    prop_zero = mean(countBurglaries == 0, na.rm = TRUE)  \n  )\n\nburg_summary\n\n```\n\n```{r}\n# Histogram\nggplot(burg_all, aes(x = countBurglaries, fill = year)) +\n  geom_histogram(position = \"identity\", alpha = 0.4, bins = 30) +\n  scale_y_continuous() +  \n  facet_wrap(~ year, ncol = 1) +\n  theme_minimal()\n\n# Box Plot\nggplot(burg_all, aes(x = year, y = countBurglaries)) +\n  geom_boxplot() +\n  coord_cartesian(ylim = c(0, quantile(burg_all$countBurglaries, 0.95))) +\n  theme_minimal()\n\n```\n\n```{r}\np4 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = countBurglaries), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Burglaries, 2018\") +\n  theme_crime()\n\nburglaries_fishnet2 <- st_join(burglaries, fishnet_raw, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countBurglaries = n())\n\nfishnet_raw <- fishnet_raw %>%\n  left_join(burglaries_fishnet, by = \"uniqueID\") %>%\n  mutate(countBurglaries = replace_na(countBurglaries, 0))\n\np4.1 <- ggplot() +\n  geom_sf(data = fishnet_raw, aes(fill = countBurglaries), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Burglaries, 2017\") +\n  theme_crime()\n\np4 + p4.1\n```\n\nDiscussion: As the descriptive statistics showed, 2018 has lower mean and variance and a higher share of zero-burglary cells than 2017, with fewer extremely intense hotspots. Also through histogram and box plots, we can see 2018 has fewer extreme data. Visually, we can also see that there are fewer intensive hotspots in 2018. This smoother target distribution naturally leads to smaller average prediction errors, even though the underlying model structure has not changed, causing the relatively lower errors (MAE & RMSE).\n\n#### Part 6.6 Summary Table\n\n```{r}\n# Create nice summary table\nmodel_summary <- broom::tidy(final_model, exponentiate = TRUE) %>%\n  mutate(\n    across(where(is.numeric), ~round(., 3))\n  )\n\nmodel_summary %>%\n  kable(\n    caption = \"Final Negative Binomial Model Coefficients (Exponentiated)\",\n    col.names = c(\"Variable\", \"Rate Ratio\", \"Std. Error\", \"Z\", \"P-Value\")\n  ) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%\n  footnote(\n    general = \"Rate ratios > 1 indicate positive association with burglary counts.\"\n  )\n```\n\nDiscussion: \n1. The count of Alley Lights Out reports has a rate ratio of 1.004 (> 1), so it is positively associated with burglaries: each additional alley-light-out report in a cell is linked to about a 0.4% increase in the expected burglary count. The effect is statistically significant (p = 0.025), but the magnitude is small.\n2. The distance to nearest neighbor of alley lights out has a rate ratio of 0.996 (< 1), so it shows a negative association: higher values of this variable measure are associated with slightly lower burglary rates. This effect is highly significant and its direction is consistent with the idea that if a cell is close to several reported light outages, which means the surrounding alleys are likely darker and less visible at night, with weaker natural surveillance, it is more likely to happen burglaries.\n3. The distance to hotspot also has a rate ratio extremely close to 1 (≈ 1.000) and is statistically significant, but the per-unit effect is tiny—each additional unit of distance only changes the expected rate by a fraction of a percent.\n\n## Step 3: Conclusion\nIn this lab, I used 311 “Alley Lights Out” service requests as a proxy for local guardianship and physical disorder to model spatial patterns of burglaries in Chicago. I aggregated the data to a fishnet grid and constructed three spatial features: the count of alley-light-out reports in each cell, the average distance from each cell to its three nearest light-out events (a k-nearest-neighbor measure), and distance to \nlight-out hotspots. Using these features, I fit Poisson and then Negative Binomial count regression models, compared the final Negative Binomial model to a KDE baseline in 2017, and evaluated its temporal robustness by predicting burglaries in 2018.\n\nThe results show that the regression model has limited predictive power. It captures the broad spatial structure of burglary risk—higher in the western and southern corridors and lower along the lakefront—but struggles with fine-grained variation and extreme hotspots. Error maps reveal systematic under-prediction in the most intense high-crime cells and over-prediction in very low-crime areas. In terms of performance metrics, the Negative Binomial model has higher MAE and RMSE than the 2017 KDE baseline, reflecting this smoother, less flexible fit. However, when applied to 2018, the model remains reasonably robust over time and even achieves slightly lower errors than in 2017, likely because the 2018 burglary distribution is less variable and contains fewer extreme peaks, making it easier to predict.\n\nThe three spatial features show interpretable but mostly modest effects. The count of alley-light-out reports has a small positive association with burglaries, suggesting that cells with more complaints about broken lights tend to experience slightly higher crime. The nearest-neighbor distance to light-out events is negatively associated with burglaries: cells that are closer to clusters of broken lights—i.e., darker, less supervised environments—have higher predicted burglary rates, while cells farther away from outages have somewhat lower risk. The distance to pre-existing burglary hotspots is statistically significant but has tiny per-unit effect.\n\nFinally, these findings need to consider the biases in 311 data. Service requests reflect not only physical conditions but also who chooses—and is able—to report problems. Historical patterns of disinvestment, unequal access to digital tools, language barriers, and varying levels of trust in local government all shape where 311 calls are made. As a result, alley-light-out complaints may under-represent infrastructure problems in some high-need neighborhoods and over-represent them in others. This reporting bias means that my model may systematically misstate conditions in marginalized communities and ultimately limit the accuracy and equity of the predictions.","srcMarkdownNoYaml":"\n\n## Assignment Overview\n\nIn this lab, I will apply the spatial predictive modeling techniques demonstrated in the class exercise to a 311 service request type of my choice. I will build a complete spatial predictive model, document your process, and interpret my results.\n\n**Learning Objectives:** - Adapt example code to analyze a new dataset - Build spatial features for predictive modeling - Apply count regression techniques to spatial data - Implement spatial cross-validation - Interpret and communicate model results - Critically evaluate model performance\n\n------------------------------------------------------------------------\n\n## Setup\n\n```{r}\n#| message: false\n#| warning: false\n\n# Load required packages\nlibrary(tidyverse)      # Data manipulation\nlibrary(sf)             # Spatial operations\nlibrary(here)           # Relative file paths\nlibrary(viridis)        # Color scales\nlibrary(terra)          # Raster operations (replaces 'raster')\nlibrary(spdep)          # Spatial dependence\nlibrary(FNN)            # Fast nearest neighbors\nlibrary(MASS)           # Negative binomial regression\nlibrary(patchwork)      # Plot composition (replaces grid/gridExtra)\nlibrary(knitr)          # Tables\nlibrary(kableExtra)     # Table formatting\nlibrary(classInt)       # Classification intervals\nlibrary(here)\n\n# Spatstat split into sub-packages\nlibrary(spatstat.geom)    # Spatial geometries\nlibrary(spatstat.explore) # Spatial exploration/KDE\n\n# Set options\noptions(scipen = 999)  # No scientific notation\nset.seed(5080)         # Reproducibility\n\n# Create consistent theme for visualizations\ntheme_crime <- function(base_size = 11) {\n  theme_minimal(base_size = base_size) +\n    theme(\n      plot.title = element_text(face = \"bold\", size = base_size + 1),\n      plot.subtitle = element_text(color = \"gray30\", size = base_size - 1),\n      legend.position = \"right\",\n      panel.grid.minor = element_blank(),\n      axis.text = element_blank(),\n      axis.title = element_blank()\n    )\n}\n\n# Set as default\ntheme_set(theme_crime())\n\ncat(\"✓ All packages loaded successfully!\\n\")\ncat(\"✓ Working directory:\", getwd(), \"\\n\")\n```\n\n## Step 1: My 311 Violation Type\n\nI chose the 311 service request type “Alley Light Out” as my violation because it provides a useful proxy for local guardianship and physical disorder when predicting burglaries. Reports of broken or non-functioning alley lights indicate areas that are poorly illuminated and less visible to neighbors or passers-by. From an environmental criminology perspective, these darker, less supervised micro-environments reduce natural surveillance and increase offenders’ perceived anonymity, making nearby properties more attractive targets for break-ins. Thus, the spatial pattern of alley-light-out complaints can reasonably be expected to correlate with higher burglary risk.\n\n## Step 2: My Analysis\n\n#### Part 1: Data Loading & Exploration\n\n```{r}\n# Load 311 data (Alley lights out)\nalley_lights <- read_csv(\"data/311_Alley_Lights_Out_2017.csv\")%>%\n  filter(!is.na(Latitude), !is.na(Longitude)) %>%\n  st_as_sf(coords = c(\"Longitude\", \"Latitude\"), crs = 4326) %>%\n  st_transform('ESRI:102271')\n```\n\n```{r}\n#| message: false\n\n# Load police districts (used for spatial cross-validation)\npoliceDistricts <- \n  st_read(\"https://data.cityofchicago.org/api/geospatial/24zt-jpfn?method=export&format=GeoJSON\") %>%\n  st_transform('ESRI:102271') %>%\n  dplyr::select(District = dist_num)\n\n# Load police beats (smaller administrative units)\npoliceBeats <- \n  st_read(\"https://data.cityofchicago.org/api/geospatial/n9it-hstw?method=export&format=GeoJSON\") %>%\n  st_transform('ESRI:102271') %>%\n  dplyr::select(Beat = beat_num)\n\n# Load Chicago boundary\nchicagoBoundary <- \n  st_read(\"https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/Chapter5/chicagoBoundary.geojson\") %>%\n  st_transform('ESRI:102271')\n\ncat(\"✓ Loaded spatial boundaries\\n\")\ncat(\"  - Police districts:\", nrow(policeDistricts), \"\\n\")\ncat(\"  - Police beats:\", nrow(policeBeats), \"\\n\")\n```\n\n```{r}\n#| fig-width: 10\n#| fig-height: 5\n\n## Visualization and Spatial Distribution\n# Simple point map\np1 <- ggplot() + \n  geom_sf(data = chicagoBoundary, fill = \"gray95\", color = \"gray60\") +\n  geom_sf(data = alley_lights, color = \"#d62828\", size = 0.1, alpha = 0.4) +\n  labs(\n    title = \"Alley Lights Out Locations\",\n    subtitle = paste0(\"Chicago 2017, n = \", nrow(alley_lights))\n  )\n\n# Density surface using modern syntax\np2 <- ggplot() + \n  geom_sf(data = chicagoBoundary, fill = \"gray95\", color = \"gray60\") +\n  geom_density_2d_filled(\n    data = data.frame(st_coordinates(alley_lights)),\n    aes(X, Y),\n    alpha = 0.7,\n    bins = 8\n  ) +\n  scale_fill_viridis_d(\n    option = \"plasma\",\n    direction = -1,\n    guide = \"none\"  # Modern ggplot2 syntax (not guide = FALSE)\n  ) +\n  labs(\n    title = \"Density Surface\",\n    subtitle = \"Kernel density estimation\"\n  )\n\n# Combine plots using patchwork (modern approach)\np1 + p2 + \n  plot_annotation(\n    title = \"Spatial Distribution of Alley Lights Out in Chicago, 2017\",\n    tag_levels = 'A'\n  )\n```\n\nSpatial Pattern: The maps show that alley-light-out reports are not evenly distributed across Chicago, but cluster in a few broad corridors. Complaints are most concentrated in a north–south band through the western and southwestern residential neighborhoods, with several pronounced hotspots in the central and South Side areas. In contrast, the lakefront, downtown core, and some far-north and far-south edges have relatively few reports, suggesting better lighting conditions or fewer alleys in those parts of the city.\n\n#### Part 2: Fishnet Grid Creation\n\n```{r}\n# Create 500m x 500m grid\nfishnet_raw <- st_make_grid(\n  chicagoBoundary,\n  cellsize = 500,  # 500 meters per cell\n  square = TRUE\n) %>%\n  st_sf() %>%\n  mutate(uniqueID = row_number())\n\n# Keep only cells that intersect Chicago\nfishnet_raw <- fishnet_raw[chicagoBoundary, ]\n\n# View basic info\ncat(\"✓ Created fishnet grid\\n\")\ncat(\"  - Number of cells:\", nrow(fishnet_raw), \"\\n\")\ncat(\"  - Cell size:\", 500, \"x\", 500, \"meters\\n\")\ncat(\"  - Cell area:\", round(st_area(fishnet_raw[1,])), \"square meters\\n\")\n```\n\n```{r}\n# Spatial join\nalley_lights_fishnet <- st_join(alley_lights, fishnet_raw, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countAlleyLights = n())\n\n# Join back to fishnet (cells with 0 will be NA)\nfishnet_raw <- fishnet_raw %>%\n  left_join(alley_lights_fishnet, by = \"uniqueID\") %>%\n  mutate(countAlleyLights = replace_na(countAlleyLights, 0))\n\n# Summary statistics\ncat(\"\\nAlleyLights count distribution:\\n\")\nsummary(fishnet_raw$countAlleyLights)\ncat(\"\\nCells with zero AlleyLights:\", \n    sum(fishnet_raw$countAlleyLights == 0), \n    \"/\", nrow(fishnet_raw),\n    \"(\", round(100 * sum(fishnet_raw$countAlleyLights == 0) / nrow(fishnet_raw), 1), \"%)\\n\")\n```\n\n```{r}\n#| fig-width: 8\n#| fig-height: 6\n\n# Visualize aggregated counts\nggplot() +\n  geom_sf(data = fishnet_raw, aes(fill = countAlleyLights), color = NA) +\n  geom_sf(data = chicagoBoundary, fill = NA, color = \"white\", linewidth = 1) +\n  scale_fill_viridis_c(\n    name = \"Alley Lights Out\",\n    option = \"plasma\",\n    trans = \"sqrt\",  # Square root for better visualization of skewed data\n    breaks = c(0, 20, 50, 100, 150)\n  ) +\n  labs(\n    title = \"Alley Lights Out Counts by Grid Cell\",\n    subtitle = \"500m x 500m cells, Chicago 2017\"\n  ) +\n  theme_crime()\n```\n\n#### Part 3: Spatial Features\n\n```{r}\n## Calculate k-nearest neighbor features\n\n# Get coordinates\nfishnet_coords <- st_coordinates(st_centroid(fishnet_raw))\nlights_coords <- st_coordinates(alley_lights)\n\n# Calculate k nearest neighbors and distances\nnn_result <- get.knnx(lights_coords, fishnet_coords, k = 3)\n\n# Add to fishnet\nfishnet <- fishnet_raw %>%\n  mutate(\n    alley_lights.nn = rowMeans(nn_result$nn.dist)\n  )\n\ncat(\"✓ Calculated nearest neighbor distances\\n\")\nsummary(fishnet$alley_lights.nn)\n\n```\n\n```{r}\n## Local Moran'I\n\n# Function to calculate Local Moran's I\ncalculate_local_morans <- function(data, variable, k = 5) {\n  \n  # Create spatial weights\n  coords <- st_coordinates(st_centroid(data))\n  neighbors <- knn2nb(knearneigh(coords, k = k))\n  weights <- nb2listw(neighbors, style = \"W\", zero.policy = TRUE)\n  \n  # Calculate Local Moran's I\n  local_moran <- localmoran(data[[variable]], weights)\n  \n  # Classify clusters\n  mean_val <- mean(data[[variable]], na.rm = TRUE)\n  \n  data %>%\n    mutate(\n      local_i = local_moran[, 1],\n      p_value = local_moran[, 5],\n      is_significant = p_value < 0.05,\n      \n      moran_class = case_when(\n        !is_significant ~ \"Not Significant\",\n        local_i > 0 & .data[[variable]] > mean_val ~ \"High-High\",\n        local_i > 0 & .data[[variable]] <= mean_val ~ \"Low-Low\",\n        local_i < 0 & .data[[variable]] > mean_val ~ \"High-Low\",\n        local_i < 0 & .data[[variable]] <= mean_val ~ \"Low-High\",\n        TRUE ~ \"Not Significant\"\n      )\n    )\n}\n\n# Apply function\nfishnet <- calculate_local_morans(fishnet, \"countAlleyLights\", k = 5)\n```\n\n```{r}\n## Identify Hot Spot\n\n#| fig-width: 8\n#| fig-height: 6\n\n# Visualize hot spots\nggplot() +\n  geom_sf(\n    data = fishnet, \n    aes(fill = moran_class), \n    color = NA\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"High-High\" = \"#d7191c\",\n      \"High-Low\" = \"#fdae61\",\n      \"Low-High\" = \"#abd9e9\",\n      \"Low-Low\" = \"#2c7bb6\",\n      \"Not Significant\" = \"gray90\"\n    ),\n    name = \"Cluster Type\"\n  ) +\n  labs(\n    title = \"Local Moran's I: Alley Lights Out Clusters\",\n    subtitle = \"High-High = Hot spots of lights out\"\n  ) +\n  theme_crime()\n```\nInterpretation: The Local Moran’s I results show that alley-light-out complaints are not randomly distributed, but form several statistically significant clusters. High–High cells (in red) – grid cells with high numbers of outages surrounded by similarly high neighbors – concentrate in contiguous bands in the central–west and southwest parts of the city, with additional pockets on the South Side. These areas represent local hot spots of poor alley lighting conditions. A few Low–High cells (in blue) appear on the edges of these clusters, indicating outliers. Most of the remaining grid cells are not significant.\n\n```{r}\n## Distance-to-hotspots\n\n# Get centroids of \"High-High\" cells (hot spots)\nhotspots <- fishnet %>%\n  filter(moran_class == \"High-High\") %>%\n  st_centroid()\n\n# Calculate distance from each cell to nearest hot spot\nif (nrow(hotspots) > 0) {\n  fishnet <- fishnet %>%\n    mutate(\n      dist_to_hotspot = as.numeric(\n        st_distance(st_centroid(fishnet), hotspots %>% st_union())\n      )\n    )\n  \n  cat(\"✓ Calculated distance to alley lights out hot spots\\n\")\n  cat(\"  - Number of hot spot cells:\", nrow(hotspots), \"\\n\")\n} else {\n  fishnet <- fishnet %>%\n    mutate(dist_to_hotspot = 0)\n  cat(\"⚠ No significant hot spots found\\n\")\n}\n```\n\n#### Part 4: Count Regression Models\n\n```{r}\n## load-burglaries\n\n#| message: false\n\n# Load from provided data file (downloaded from Chicago open data portal)\nburglaries <- st_read(\"data/burglaries.shp\") %>% \n  st_transform('ESRI:102271')\n\n# Check the data\ncat(\"\\n✓ Loaded burglary data\\n\")\ncat(\"  - Number of burglaries:\", nrow(burglaries), \"\\n\")\ncat(\"  - CRS:\", st_crs(burglaries)$input, \"\\n\")\ncat(\"  - Date range:\", min(burglaries$date, na.rm = TRUE), \"to\", \n    max(burglaries$date, na.rm = TRUE), \"\\n\")\n```\n\n```{r}\n## Aggregate burglary data to fishnet\n\n# Spatial join: which cell contains each burglary?\nburglaries_fishnet <- st_join(burglaries, fishnet, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countBurglaries = n())\n\n# Join back to fishnet (cells with 0 burglaries will be NA)\nfishnet <- fishnet %>%\n  left_join(burglaries_fishnet, by = \"uniqueID\") %>%\n  mutate(countBurglaries = replace_na(countBurglaries, 0))\n\n# Summary statistics\ncat(\"\\nBurglary count distribution:\\n\")\nsummary(fishnet$countBurglaries)\ncat(\"\\nCells with zero burglaries:\", \n    sum(fishnet$countBurglaries == 0), \n    \"/\", nrow(fishnet),\n    \"(\", round(100 * sum(fishnet$countBurglaries == 0) / nrow(fishnet), 1), \"%)\\n\")\n```\n\n```{r}\n## KDE \n\n#| message: false\n\n# Convert burglaries to ppp (point pattern) format for spatstat\nburglaries_ppp <- as.ppp(\n  st_coordinates(burglaries),\n  W = as.owin(st_bbox(chicagoBoundary))\n)\n\n# Calculate KDE with 1km bandwidth\nkde_burglaries <- density.ppp(\n  burglaries_ppp,\n  sigma = 1000,  # 1km bandwidth\n  edge = TRUE    # Edge correction\n)\n\n# Convert to terra raster (modern approach, not raster::raster)\nkde_raster <- rast(kde_burglaries)\n\n# Extract KDE values to fishnet cells\nfishnet <- fishnet %>%\n  mutate(\n    kde_value = terra::extract(\n      kde_raster,\n      vect(fishnet),\n      fun = mean,\n      na.rm = TRUE\n    )[, 2]  # Extract just the values column\n  )\n\ncat(\"✓ Calculated KDE baseline\\n\")\n```\n\n```{r}\n# Join district information to fishnet\nfishnet <- st_join(\n  fishnet,\n  policeDistricts,\n  join = st_within,\n  left = TRUE\n) %>%\n  filter(!is.na(District))  # Remove cells outside districts\n\ncat(\"✓ Joined police districts\\n\")\ncat(\"  - Districts:\", length(unique(fishnet$District)), \"\\n\")\ncat(\"  - Cells:\", nrow(fishnet), \"\\n\")\n```\n\n```{r}\n## Fit Poisson regression\n# Create clean modeling dataset\nfishnet_model <- fishnet %>%\n  st_drop_geometry() %>%\n  dplyr::select(\n    uniqueID,\n    District,\n    countBurglaries,\n    countAlleyLights,\n    alley_lights.nn,\n    dist_to_hotspot\n  ) %>%\n  na.omit()  # Remove any remaining NAs\n\n#Poisson regression\nmodel_poisson <- glm(\n  countBurglaries ~ countAlleyLights + alley_lights.nn + dist_to_hotspot,\n  data = fishnet_model,\n  family = \"poisson\"\n)\n\n# Summary\nsummary(model_poisson)\n```\n\n```{r}\n# Calculate dispersion parameter\ndispersion <- sum(residuals(model_poisson, type = \"pearson\")^2) / \n              model_poisson$df.residual\n\ncat(\"Dispersion parameter:\", round(dispersion, 2), \"\\n\")\ncat(\"Rule of thumb: >1.5 suggests overdispersion\\n\")\n\nif (dispersion > 1.5) {\n  cat(\"⚠ Overdispersion detected! Consider Negative Binomial model.\\n\")\n} else {\n  cat(\"✓ Dispersion looks okay for Poisson model.\\n\")\n}\n```\n\n```{r}\n# Fit Negative Binomial model\nmodel_nb <- glm.nb(\n  countBurglaries ~ countAlleyLights + alley_lights.nn + dist_to_hotspot,\n  data = fishnet_model\n)\n\n# Summary\nsummary(model_nb)\n\n# Compare AIC (lower is better)\ncat(\"\\nModel Comparison:\\n\")\ncat(\"Poisson AIC:\", round(AIC(model_poisson), 1), \"\\n\")\ncat(\"Negative Binomial AIC:\", round(AIC(model_nb), 1), \"\\n\")\n```\nComparison between 2 models: The Poisson model shows strong overdispersion, with a dispersion parameter of about 3.28 (>1.5), indicating that the variance is much larger than the mean and the Poisson assumption is violated, so Negative Binomial model should be applied. Compared with the Poisson model, the Negative Binomial model provides a clearly superior fit to the burglary counts, its AIC (7562.6) is dramatically lower than the Poisson AIC (9057.4).\n\n#### Part 5: Spatial Cross-Validation (2017)\n\n```{r}\n# Get unique districts\ndistricts <- unique(fishnet_model$District)\ncv_results <- tibble()\n\ncat(\"Running LOGO Cross-Validation...\\n\")\n\nfor (i in seq_along(districts)) {\n  \n  test_district <- districts[i]\n  \n  # Split data\n  train_data <- fishnet_model %>% filter(District != test_district)\n  test_data <- fishnet_model %>% filter(District == test_district)\n  \n  # Fit model on training data\n  model_cv <- glm.nb(\n    countBurglaries ~ countAlleyLights + alley_lights.nn + dist_to_hotspot,\n    data = train_data\n  )\n  \n  # Predict on test data\n  test_data <- test_data %>%\n    mutate(\n      prediction = predict(model_cv, test_data, type = \"response\")\n    )\n  \n  # Calculate metrics\n  mae <- mean(abs(test_data$countBurglaries - test_data$prediction))\n  rmse <- sqrt(mean((test_data$countBurglaries - test_data$prediction)^2))\n  \n  # Store results\n  cv_results <- bind_rows(\n    cv_results,\n    tibble(\n      fold = i,\n      test_district = test_district,\n      n_test = nrow(test_data),\n      mae = mae,\n      rmse = rmse\n    )\n  )\n  \n  cat(\"  Fold\", i, \"/\", length(districts), \"- District\", test_district, \n      \"- MAE:\", round(mae, 2), \"\\n\")\n}\n\n# Overall results\ncat(\"\\n✓ Cross-Validation Complete\\n\")\ncat(\"Mean MAE:\", round(mean(cv_results$mae), 2), \"\\n\")\ncat(\"Mean RMSE:\", round(mean(cv_results$rmse), 2), \"\\n\")\n\n```\n\nDiscussion: In this step I use spatial cross-validation, leaving out one police district at a time (LOGO CV). The reason for using a spatial CV scheme instead of random k-folds is that burglary patterns might be spatially autocorrelated: nearby cells look more similar than distant ones. A random split would mix neighboring cells across training and test sets, making the test data “too easy” and over-optimistic about model performance. By holding out an entire district, I can reveal how well does the model trained on some parts of Chicago generalize to a completely new area, which is a more robust way to test the prediction ability.\n\nThe results suggest that the model’s out-of-sample predictive ability is only low-moderate. The average MAE across folds is about 2.58 burglaries per grid cell, and the mean RMSE is 3.5, which are large. There is also substantial variation across districts: some folds have relatively low errors (MAE around 1.8–2.0), while others—such as District 3—show much higher errors (MAE above 5). This pattern indicates that the model captures some broad spatial structure, but its ability to generalize to all districts is limited, and performance degrades notably in certain areas.\n\n#### Part 6: Model Evaluation (Spatial and Temporal)\n\n#### Part 6.0 Use Final Model to Make Predictions\n\n```{r}\nfinal_model <- glm.nb(\n  countBurglaries ~ countAlleyLights + alley_lights.nn + dist_to_hotspot,\n  data = fishnet_model\n)\n```\n\n```{r}\n## Generate three predictors for 2018\n\n# 0) Load 2018 311 data\nalley_lights_2018 <- read_csv(\"data/311_Alley_Lights_Out_2018.csv\")%>%\n  filter(!is.na(Latitude), !is.na(Longitude)) %>%\n  st_as_sf(coords = c(\"Longitude\", \"Latitude\"), crs = 4326) %>%\n  st_transform('ESRI:102271')\n\n# 0) Prepare 500m x 500m grid for 2018\nfishnet2 <- st_make_grid(\n  chicagoBoundary,\n  cellsize = 500,  # 500 meters per cell\n  square = TRUE\n) %>%\n  st_sf() %>%\n  mutate(uniqueID = row_number())\n\nfishnet2 <- fishnet2[chicagoBoundary, ]\n\n# 1) Aggregate into fishnet\nalley_lights_fishnet_2018 <- st_join(alley_lights_2018, fishnet2, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countAlleyLights = n())\n\n# Join back to fishnet (cells with 0 will be NA)\nfishnet2 <- fishnet2 %>%\n  left_join(alley_lights_fishnet_2018, by = \"uniqueID\") %>%\n  mutate(countAlleyLights = replace_na(countAlleyLights, 0))\n\n# 2) Calculate k-nearest neighbor features\nfishnet2_coords <- st_coordinates(st_centroid(fishnet2))\nlights2018_coords <- st_coordinates(alley_lights_2018)\n\n# Calculate k nearest neighbors and distances\nnn_result2 <- get.knnx(lights2018_coords, fishnet2_coords, k = 3)\n\n# Add to fishnet\nfishnet2 <- fishnet2 %>%\n  mutate(\n    alley_lights.nn = rowMeans(nn_result2$nn.dist)\n  )\n\n# 3) Distance to hotspot\n# Apply function\nfishnet2 <- calculate_local_morans(fishnet2, \"countAlleyLights\", k = 5)\n\n# Get centroids of \"High-High\" cells (hot spots)\nhotspots <- fishnet2 %>%\n  filter(moran_class == \"High-High\") %>%\n  st_centroid()\n\nif (nrow(hotspots) > 0) {\n  fishnet2 <- fishnet2 %>%\n    mutate(\n      dist_to_hotspot = as.numeric(\n        st_distance(st_centroid(fishnet2), hotspots %>% st_union())\n      )\n    )\n  \n  cat(\"✓ Calculated distance to alley lights out hot spots\\n\")\n  cat(\"  - Number of hot spot cells:\", nrow(hotspots), \"\\n\")\n} else {\n  fishnet <- fishnet %>%\n    mutate(dist_to_hotspot = 0)\n  cat(\"⚠ No significant hot spots found\\n\")\n}\n\n```\n\n```{r}\n## burglaries data for 2018\nburglaries_2018 <- st_read(\"data/burglaries_2018.geojson\") %>% \n  st_transform('ESRI:102271')\n\n# Spatial join\nburglaries_fishnet2 <- st_join(burglaries_2018, fishnet2, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countBurglaries = n())\n\n# Join back to fishnet (cells with 0 burglaries will be NA)\nfishnet2 <- fishnet2 %>%\n  left_join(burglaries_fishnet2, by = \"uniqueID\") %>%\n  mutate(countBurglaries = replace_na(countBurglaries, 0))\n\n# Create clean dataset for prediction\nfishnet_model_2018 <- fishnet2 %>%\n  st_drop_geometry() %>%\n  dplyr::select(\n    uniqueID,\n    countBurglaries,\n    countAlleyLights,\n    alley_lights.nn,\n    dist_to_hotspot\n  ) %>%\n  na.omit()  # Remove any remaining NAs\n\n```\n\n```{r}\n## Add predictions back to fishnet for both year\n\nfishnet <- fishnet %>%\n  mutate(\n    prediction_nb = predict(final_model, fishnet_model, type = \"response\")[match(uniqueID, fishnet_model$uniqueID)]\n  )\n\nfishnet2 <- fishnet2 %>%\n  mutate(\n    prediction_nb = predict(final_model, fishnet_model_2018, type = \"response\")[match(uniqueID, fishnet_model_2018$uniqueID)]\n  )\n\n# KDE predictions as baseline (normalize to same scale as counts)\nkde_sum <- sum(fishnet$kde_value, na.rm = TRUE)\ncount_sum <- sum(fishnet$countBurglaries, na.rm = TRUE)\nfishnet <- fishnet %>%\n  mutate(\n    prediction_kde = (kde_value / kde_sum) * count_sum\n  )\n```\n\n#### Part 6.1 Compare Model vs. KDE Baseline (Spatially)\n\n```{r}\n#| fig-width: 18\n#| fig-height: 10\n\n# Create three maps\n\np1 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = countBurglaries), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Burglaries, 2017\") +\n  theme_crime()\n\np2 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = prediction_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Model Predictions (Neg. Binomial), 2017\") +\n  theme_crime()\n\np3 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = prediction_kde), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"KDE Baseline Predictions, 2017\") +\n  theme_crime()\n\np1 + p2 + p3 +\n  plot_annotation(\n    title = \"Actual vs. Predicted Burglaries, 2017\",\n    subtitle = \"Caomparasion between actual values, model predictions, and KDE Baseline\"\n  )\n```\n\nDiscussion: Compared with actual plot, the Negative Binomial model reproduces the broad spatial pattern of burglaries in 2017. The model surface is clearly smoother than the real observations: many small, high-intensity hotspots in the actual map are muted or averaged out, and extreme peaks are under-predicted.\n  \nCompared with the KDE baseline, the regression model captures more local variation and better respects the grid/district structure. The KDE surface is very smooth and spreads risk over large blobs, often blurring sharp transitions between high- and low-burglary cells. By contrast, the model predictions show finer spatial detail and align more closely with the observed hotspot pattern, even though they still miss some of the most intense clusters.\n\n#### Part 6.2 Compare Model (Temporally)\n\n```{r}\n#| fig-width: 18\n#| fig-height: 10\n\n# Create three maps\n\np4 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = countBurglaries), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Burglaries, 2018\") +\n  theme_crime()\n\np5 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = prediction_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Model Predictions (Neg. Binomial), 2018\") +\n  theme_crime()\n\np4 + p5 +\n  plot_annotation(\n    title = \"Actual vs. Predicted Burglaries, 2018\",\n    subtitle = \"Caomparasion between actual values and model predictions, 2018\"\n  )\n```\n\nDiscussion: In the temporal validation for 2018, the Negative Binomial model again reproduces the broad spatial structure of burglaries, but the limitations of its predictive power are also apparent. The predicted surface correctly identifies the western and southern parts of the city as higher-risk areas and keeps the lakefront and far-south tip relatively low, so at a coarse scale the model generalizes reasonably well from 2017 to 2018. However, the 2018 predictions are even smoother and more diffuse than in the training year: many of the sharp, localized hotspots visible in the actual 2018 map are blurred into medium-intensity regions, and several newly emerging hotspots are clearly under-predicted. \n\n#### Part 6.3 Map Prediction Errors for 2017 and 2018\n\n```{r}\n## Map prediction errors for 2017 and 2018\n# Calculate errors\nfishnet <- fishnet %>%\n  mutate(\n    error_nb = countBurglaries - prediction_nb,\n    error_kde = countBurglaries - prediction_kde,\n    abs_error_nb = abs(error_nb),\n    abs_error_kde = abs(error_kde)\n  )\n\nfishnet2 <- fishnet2 %>%\n  mutate(\n    error_nb = countBurglaries - prediction_nb,\n    abs_error_nb = abs(error_nb),\n  )\n\n# Map errors\np6 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = error_nb), color = NA) +\n  scale_fill_gradient2(\n    name = \"Error\",\n    low = \"#2166ac\", mid = \"white\", high = \"#b2182b\",\n    midpoint = 0,\n    limits = c(-10, 10)\n  ) +\n  labs(title = \"Model Errors (Actual - Predicted), 2017\") +\n  theme_crime()\n\np7 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = abs_error_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Abs. Error\", option = \"magma\") +\n  labs(title = \"Absolute Model Errors, 2017\") +\n  theme_crime()\n\n\n\np6 + p7\n```\n\n```{r}\n# Map errors\np8 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = error_nb), color = NA) +\n  scale_fill_gradient2(\n    name = \"Error\",\n    low = \"#2166ac\", mid = \"white\", high = \"#b2182b\",\n    midpoint = 0,\n    limits = c(-10, 10)\n  ) +\n  labs(title = \"Model Errors (Actual - Predicted), 2018\") +\n  theme_crime()\n\np9 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = abs_error_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Abs. Error\", option = \"magma\") +\n  labs(title = \"Absolute Model Errors, 2018\") +\n  theme_crime()\n\np8 + p9\n```\n\nDiscussion: Across both years, the error maps show clear local patterns of errors. In 2017, red cells (under-prediction) are concentrated in the main burglary hotspots in the north-western and southern parts of the city, where the model tends to miss the very highest counts. Blue cells (over-prediction) appear more often along the lakefront and some peripheral districts, where actual burglaries are close to zero but the model still assigns non-trivial risk. The absolute-error map confirms that the largest errors are clustered in these high-crime southern and southwestern areas.\n\nIn 2018, the pattern is similar. Cells show sightly lower  absolute errors, but still a handful of high-burglary grids in the south stand out with large residuals. Overall, the model performs best in medium-risk areas and struggles most with extreme hotspots and very low-crime zones.\n\n#### Part 6.4 Performance Metrics\n\n```{r}\n## Calculate performance metrics\n\ncomparison <- fishnet %>%\n  st_drop_geometry() %>%\n  filter(!is.na(prediction_nb), !is.na(prediction_kde)) %>%\n  summarize(\n    model_mae_2017 = mean(abs(countBurglaries - prediction_nb)),\n    model_rmse_2017 = sqrt(mean((countBurglaries - prediction_nb)^2)),\n    kde_mae = mean(abs(countBurglaries - prediction_kde)),\n    kde_rmse = sqrt(mean((countBurglaries - prediction_kde)^2))\n  )\n\ncomparison2 <- fishnet2 %>%\n  st_drop_geometry() %>%\n  filter(!is.na(prediction_nb)) %>%\n  summarize(\n    model_mae_2018 = mean(abs(countBurglaries - prediction_nb)),\n    model_rmse_2018 = sqrt(mean((countBurglaries - prediction_nb)^2))\n  )\n\nperf_table <- tibble::tibble(\n  Model = c(\n    \"KDE Baseline in 2017\",\n    \"NegBin Model in 2017\",\n    \"NegBin Model in 2018\"\n  ),\n  MAE = c(\n    comparison$kde_mae,#### Part 6.4 Performance Metrics\n    comparison$model_mae_2017,\n    comparison2$model_mae_2018\n  ),\n  RMSE = c(\n    comparison$kde_rmse,\n    comparison$model_rmse_2017,\n    comparison2$model_rmse_2018\n  )\n)\n\nperf_table %>%\n  knitr::kable(\n    digits = 2,\n    caption = \"Model Performance Comparison (2017 & 2018)\"\n  ) %>%\n  kableExtra::kable_styling(\n    bootstrap_options = c(\"striped\", \"hover\")\n  )\n```\n\nDiscussion: The performance table shows that the KDE baseline achieves the lowest error in the training year (2017), with MAE 2.06 and RMSE 2.95, while the Negative Binomial model performs slightly worse in 2017 (MAE 2.44, RMSE 3.50). This can be explained by that the KDE baseline is a purely spatial smoothing of the observed burglary counts, so it is very flexible and can closely reproduce the 2017 hotspot pattern, especially when evaluated on the same year it was built from. In contrast, the Negative Binomial model is more relies on a small set of features (alley lights and distance to hotspots) so it cannot capture all the local variation in the training data. \n\nWhen the model is applied to 2018 for temporal validation, its error decreases (MAE 2.17, RMSE 3.18) compared with its 2017 performance, suggesting that its generalization ability is robust across years. Interestingly, the 2018 error is only slightly higher than the KDE baseline in 2017, but lower than the error in 2017. A likely explanation is that the 2018 burglary distribution itself is “easier” to predict. So a supplementary analysis might be required to see the difference of burglaries distribution between 2017 and 2018.\n\n#### Part 6.5 Supplementary Analysis to Discuss the Difference of Burglaries between 2017 and 2018\n\n```{r}\nburg_all <- bind_rows(\n  fishnet_model      %>% st_drop_geometry() %>% mutate(year = \"2017\"),\n  fishnet_model_2018 %>% st_drop_geometry() %>% mutate(year = \"2018\")\n)\n\nburg_summary <- burg_all %>%\n  group_by(year) %>%\n  summarise(\n    mean   = mean(countBurglaries, na.rm = TRUE),\n    sd     = sd(countBurglaries, na.rm = TRUE),\n    median = median(countBurglaries, na.rm = TRUE),\n    p90    = quantile(countBurglaries, 0.9, na.rm = TRUE),\n    max    = max(countBurglaries, na.rm = TRUE),\n    prop_zero = mean(countBurglaries == 0, na.rm = TRUE)  \n  )\n\nburg_summary\n\n```\n\n```{r}\n# Histogram\nggplot(burg_all, aes(x = countBurglaries, fill = year)) +\n  geom_histogram(position = \"identity\", alpha = 0.4, bins = 30) +\n  scale_y_continuous() +  \n  facet_wrap(~ year, ncol = 1) +\n  theme_minimal()\n\n# Box Plot\nggplot(burg_all, aes(x = year, y = countBurglaries)) +\n  geom_boxplot() +\n  coord_cartesian(ylim = c(0, quantile(burg_all$countBurglaries, 0.95))) +\n  theme_minimal()\n\n```\n\n```{r}\np4 <- ggplot() +\n  geom_sf(data = fishnet2, aes(fill = countBurglaries), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Burglaries, 2018\") +\n  theme_crime()\n\nburglaries_fishnet2 <- st_join(burglaries, fishnet_raw, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(countBurglaries = n())\n\nfishnet_raw <- fishnet_raw %>%\n  left_join(burglaries_fishnet, by = \"uniqueID\") %>%\n  mutate(countBurglaries = replace_na(countBurglaries, 0))\n\np4.1 <- ggplot() +\n  geom_sf(data = fishnet_raw, aes(fill = countBurglaries), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Burglaries, 2017\") +\n  theme_crime()\n\np4 + p4.1\n```\n\nDiscussion: As the descriptive statistics showed, 2018 has lower mean and variance and a higher share of zero-burglary cells than 2017, with fewer extremely intense hotspots. Also through histogram and box plots, we can see 2018 has fewer extreme data. Visually, we can also see that there are fewer intensive hotspots in 2018. This smoother target distribution naturally leads to smaller average prediction errors, even though the underlying model structure has not changed, causing the relatively lower errors (MAE & RMSE).\n\n#### Part 6.6 Summary Table\n\n```{r}\n# Create nice summary table\nmodel_summary <- broom::tidy(final_model, exponentiate = TRUE) %>%\n  mutate(\n    across(where(is.numeric), ~round(., 3))\n  )\n\nmodel_summary %>%\n  kable(\n    caption = \"Final Negative Binomial Model Coefficients (Exponentiated)\",\n    col.names = c(\"Variable\", \"Rate Ratio\", \"Std. Error\", \"Z\", \"P-Value\")\n  ) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%\n  footnote(\n    general = \"Rate ratios > 1 indicate positive association with burglary counts.\"\n  )\n```\n\nDiscussion: \n1. The count of Alley Lights Out reports has a rate ratio of 1.004 (> 1), so it is positively associated with burglaries: each additional alley-light-out report in a cell is linked to about a 0.4% increase in the expected burglary count. The effect is statistically significant (p = 0.025), but the magnitude is small.\n2. The distance to nearest neighbor of alley lights out has a rate ratio of 0.996 (< 1), so it shows a negative association: higher values of this variable measure are associated with slightly lower burglary rates. This effect is highly significant and its direction is consistent with the idea that if a cell is close to several reported light outages, which means the surrounding alleys are likely darker and less visible at night, with weaker natural surveillance, it is more likely to happen burglaries.\n3. The distance to hotspot also has a rate ratio extremely close to 1 (≈ 1.000) and is statistically significant, but the per-unit effect is tiny—each additional unit of distance only changes the expected rate by a fraction of a percent.\n\n## Step 3: Conclusion\nIn this lab, I used 311 “Alley Lights Out” service requests as a proxy for local guardianship and physical disorder to model spatial patterns of burglaries in Chicago. I aggregated the data to a fishnet grid and constructed three spatial features: the count of alley-light-out reports in each cell, the average distance from each cell to its three nearest light-out events (a k-nearest-neighbor measure), and distance to \nlight-out hotspots. Using these features, I fit Poisson and then Negative Binomial count regression models, compared the final Negative Binomial model to a KDE baseline in 2017, and evaluated its temporal robustness by predicting burglaries in 2018.\n\nThe results show that the regression model has limited predictive power. It captures the broad spatial structure of burglary risk—higher in the western and southern corridors and lower along the lakefront—but struggles with fine-grained variation and extreme hotspots. Error maps reveal systematic under-prediction in the most intense high-crime cells and over-prediction in very low-crime areas. In terms of performance metrics, the Negative Binomial model has higher MAE and RMSE than the 2017 KDE baseline, reflecting this smoother, less flexible fit. However, when applied to 2018, the model remains reasonably robust over time and even achieves slightly lower errors than in 2017, likely because the 2018 burglary distribution is less variable and contains fewer extreme peaks, making it easier to predict.\n\nThe three spatial features show interpretable but mostly modest effects. The count of alley-light-out reports has a small positive association with burglaries, suggesting that cells with more complaints about broken lights tend to experience slightly higher crime. The nearest-neighbor distance to light-out events is negatively associated with burglaries: cells that are closer to clusters of broken lights—i.e., darker, less supervised environments—have higher predicted burglary rates, while cells farther away from outages have somewhat lower risk. The distance to pre-existing burglary hotspots is statistically significant but has tiny per-unit effect.\n\nFinally, these findings need to consider the biases in 311 data. Service requests reflect not only physical conditions but also who chooses—and is able—to report problems. Historical patterns of disinvestment, unequal access to digital tools, language barriers, and varying levels of trust in local government all shape where 311 calls are made. As a result, alley-light-out complaints may under-represent infrastructure problems in some high-need neighborhoods and over-represent them in others. This reporting bias means that my model may systematically misstate conditions in marginalized communities and ultimately limit the accuracy and equity of the predictions."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"embed-resources":true,"output-file":"assignment4.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.24","theme":"cosmo","title":"Assignment 4: Spatial Predictive Analysis","author":"Zimu DENG (Mark)","date":"today","toc-location":"left"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}